import { writeFile, mkdir, readFile } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import crypto from 'node:crypto';
import { designTokens } from '../../styles/tokens/design-tokens.ts';

const HEADER = `// Generated by scripts/tokens/sync.ts - DO NOT EDIT\n`;

const DEFAULT_OUTPUT_DIR = 'styles/tokens';
const TOKEN_JSON_PATH = 'styles/tokens.json';
const TOKEN_HASH_PATH = '.cache/tokens.hash';

type TokenBag = typeof designTokens;

type WriteMode = 'sync' | 'check';

export interface SyncResult {
  wrote: string[];
  skipped: string[];
  stale: string[];
  hash: string;
}

export interface SyncOptions {
  root?: string;
  mode?: WriteMode;
}

interface Artifact {
  relativePath: string;
  contents: string;
}

const COLOR_THEME_ORDER = ['light', 'dark'];

function needsQuoting(key: string): boolean {
  if (/^[a-zA-Z_][a-zA-Z0-9_-]*$/.test(key) === false) {
    return true;
  }
  if (key.includes('-')) {
    return true;
  }
  return false;
}

function formatKey(key: string): string {
  return needsQuoting(key) ? `'${key}'` : key;
}

function formatScalar(value: string | number): string {
  if (typeof value === 'number') {
    return String(value);
  }
  if (/^\d/.test(value)) {
    return value;
  }
  return value;
}

function formatMap(value: Record<string, unknown>, indentLevel = 1): string {
  const indent = '  '.repeat(indentLevel);
  const closingIndent = '  '.repeat(indentLevel - 1);
  const lines: string[] = ['('];

  for (const [key, child] of Object.entries(value)) {
    const formattedKey = formatKey(key);

    if (child !== null && typeof child === 'object' && !Array.isArray(child)) {
      lines.push(
        `${indent}${formattedKey}: ${formatMap(child as Record<string, unknown>, indentLevel + 1)},`,
      );
    } else if (Array.isArray(child)) {
      const listValues = child
        .map((entry) =>
          typeof entry === 'object'
            ? formatMap(entry as Record<string, unknown>, indentLevel + 1)
            : formatScalar(entry as string | number),
        )
        .join(', ');
      lines.push(`${indent}${formattedKey}: (${listValues}),`);
    } else {
      lines.push(`${indent}${formattedKey}: '${String(child)}',`);
    }
  }

  lines.push(`${closingIndent})`);
  return lines.join('\n');
}

function buildColorsScss(tokens: TokenBag['colors']): string {
  const sections: string[] = [
    HEADER,
    "@use 'sass:map';",
    "@use 'sass:string';",
    '',
    '$color-tokens: (',
  ];
  for (const themeName of COLOR_THEME_ORDER) {
    const mapForTheme = tokens[themeName as keyof TokenBag['colors']];
    if (!mapForTheme) continue;
    sections.push(`  '${themeName}': ${formatMap(mapForTheme, 2)},`);
  }
  sections.push(');', '');
  sections.push(`@function color($token, $theme: 'light') {`);
  sections.push('  $theme-map: map.get($color-tokens, $theme);');
  sections.push(
    "  @if $theme-map == null {\n    @error 'Unknown theme passed to color(): #{ $theme }';\n  }",
  );
  sections.push('  $value: map.get($theme-map, $token);');
  sections.push(
    "  @if $value == null {\n    @error 'Unknown color token: #{ $token } for theme #{ $theme }';\n  }",
  );
  sections.push('  @return string.unquote($value);');
  sections.push('}', '');
  sections.push('@mixin emit-theme($theme) {');
  sections.push('  $theme-map: map.get($color-tokens, $theme);');
  sections.push(
    "  @if $theme-map == null {\n    @error 'Unknown theme passed to emit-theme(): #{ $theme }';\n  }",
  );
  sections.push('  @each $token, $value in $theme-map {');
  sections.push('    --color-#{ $token }: #{ string.unquote($value) };\n  }');
  sections.push('}');
  sections.push('');
  return sections.join('\n');
}

function buildSimpleMapScss({
  mapName,
  tokens,
  helper,
}: {
  mapName: string;
  tokens: Record<string, string | number>;
  helper: {
    name: string;
    body: string[];
  };
}): string {
  const sections: string[] = [
    HEADER,
    "@use 'sass:map';",
    "@use 'sass:string';",
    '',
    `$${mapName}: ${formatMap(tokens)};`,
    '',
  ];
  sections.push(`@function ${helper.name}($token) {`);
  sections.push(`  $value: map.get($${mapName}, $token);`);
  sections.push(
    `  @if $value == null {\n    @error 'Unknown ${helper.name} token: #{ $token }';\n  }`,
  );
  for (const line of helper.body) {
    sections.push(`  ${line}`);
  }
  sections.push('}');
  sections.push('');
  return sections.join('\n');
}

function buildTypographyScss(tokens: TokenBag['typography']): string {
  const sections: string[] = [
    HEADER,
    "@use 'sass:map';",
    "@use 'sass:string';",
    '',
    `$typography-tokens: ${formatMap(tokens)};`,
    '',
  ];
  sections.push('@mixin apply($token) {');
  sections.push('  $styles: map.get($typography-tokens, $token);');
  sections.push(
    "  @if $styles == null {\n    @error 'Unknown typography token: #{ $token }';\n  }",
  );
  sections.push('  @each $property, $value in $styles {');
  sections.push('    #{ $property }: #{ string.unquote($value) };');
  sections.push('  }');
  sections.push('}');
  sections.push('');
  return sections.join('\n');
}

function toKebabCase(value: string): string {
  return value.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
}

function transformTypographyForScss(
  tokens: TokenBag['typography'],
): Record<string, Record<string, string | number>> {
  const result: Record<string, Record<string, string | number>> = {};
  for (const [token, styles] of Object.entries(tokens)) {
    const normalized: Record<string, string | number> = {};
    for (const [property, value] of Object.entries(styles)) {
      normalized[toKebabCase(property)] = value;
    }
    result[token] = normalized;
  }
  return result;
}

function collectArtifacts(tokens: TokenBag): Artifact[] {
  const artifacts: Artifact[] = [];

  artifacts.push({
    relativePath: path.join(DEFAULT_OUTPUT_DIR, '_colors.scss'),
    contents: buildColorsScss(tokens.colors),
  });

  artifacts.push({
    relativePath: path.join(DEFAULT_OUTPUT_DIR, '_spacing.scss'),
    contents: buildSimpleMapScss({
      mapName: 'spacing-tokens',
      tokens: tokens.spacing,
      helper: {
        name: 'spacing',
        body: ['@return string.unquote($value);'],
      },
    }),
  });

  artifacts.push({
    relativePath: path.join(DEFAULT_OUTPUT_DIR, '_radii.scss'),
    contents: buildSimpleMapScss({
      mapName: 'radius-tokens',
      tokens: tokens.radii,
      helper: {
        name: 'radius',
        body: ['@return string.unquote($value);'],
      },
    }),
  });

  artifacts.push({
    relativePath: path.join(DEFAULT_OUTPUT_DIR, '_typography.scss'),
    contents: buildTypographyScss(transformTypographyForScss(tokens.typography)),
  });

  const json = `${JSON.stringify(tokens, null, 2)}\n`;
  artifacts.push({ relativePath: TOKEN_JSON_PATH, contents: json });

  return artifacts;
}

function hashArtifacts(artifacts: Artifact[]): string {
  const hash = crypto.createHash('sha256');
  for (const { relativePath, contents } of artifacts) {
    hash.update(relativePath);
    hash.update('\0');
    hash.update(contents);
    hash.update('\0');
  }
  return hash.digest('hex');
}

async function ensureDirectory(dir: string) {
  if (!existsSync(dir)) {
    await mkdir(dir, { recursive: true });
  }
}

async function readExisting(pathname: string): Promise<string | null> {
  try {
    return await readFile(pathname, 'utf8');
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return null;
    }
    throw error;
  }
}

async function writeArtifact(
  { relativePath, contents }: Artifact,
  root: string,
  mode: WriteMode,
): Promise<'wrote' | 'skipped' | 'stale'> {
  const fullPath = path.join(root, relativePath);
  const directory = path.dirname(fullPath);
  await ensureDirectory(directory);

  const existing = await readExisting(fullPath);
  if (mode === 'check') {
    if (existing === null) {
      return 'stale';
    }
    return existing === contents ? 'skipped' : 'stale';
  }

  if (existing === contents) {
    return 'skipped';
  }

  await writeFile(fullPath, contents, 'utf8');
  return 'wrote';
}

export async function syncTokens({
  root = process.cwd(),
  mode = 'sync',
}: SyncOptions = {}): Promise<SyncResult> {
  const artifacts = collectArtifacts(designTokens);
  const hash = hashArtifacts(artifacts);

  const wrote: string[] = [];
  const skipped: string[] = [];
  const stale: string[] = [];

  for (const artifact of artifacts) {
    const result = await writeArtifact(artifact, root, mode);
    if (result === 'wrote') {
      wrote.push(artifact.relativePath);
    } else if (result === 'skipped') {
      skipped.push(artifact.relativePath);
    } else {
      stale.push(artifact.relativePath);
    }
  }

  const hashTarget = path.join(root, TOKEN_HASH_PATH);
  const hashDir = path.dirname(hashTarget);
  await ensureDirectory(hashDir);

  if (mode === 'check') {
    const existing = await readExisting(hashTarget);
    if (existing === null || existing.trim() !== hash) {
      stale.push(TOKEN_HASH_PATH);
    } else if (stale.length > 0) {
      stale.push(TOKEN_HASH_PATH);
    }
  } else {
    const existing = await readExisting(hashTarget);
    if (existing !== `${hash}\n`) {
      await writeFile(hashTarget, `${hash}\n`, 'utf8');
      wrote.push(TOKEN_HASH_PATH);
    } else {
      skipped.push(TOKEN_HASH_PATH);
    }
  }

  return { wrote, skipped, stale, hash };
}

async function runFromCli() {
  const args = new Set(process.argv.slice(2));
  const mode: WriteMode = args.has('--check') ? 'check' : 'sync';
  try {
    const result = await syncTokens({ mode });
    if (mode === 'check') {
      if (result.stale.length > 0) {
        console.error('Token artifacts are out of sync. Run `pnpm tokens:sync` to regenerate:');
        for (const file of result.stale) {
          console.error(` - ${file}`);
        }
        process.exitCode = 1;
      } else {
        console.log('Token artifacts are up to date.');
      }
      return;
    }

    if (result.wrote.length > 0) {
      console.log('Updated token artifacts:');
      for (const file of result.wrote) {
        console.log(` - ${file}`);
      }
    } else {
      console.log('Token artifacts already up to date.');
    }
  } catch (error) {
    console.error('Failed to sync tokens.');
    console.error(error);
    process.exitCode = 1;
  }
}

const scriptPath = fileURLToPath(import.meta.url);
if (process.argv[1] && path.resolve(process.argv[1]) === scriptPath) {
  void runFromCli();
}

export { collectArtifacts };
