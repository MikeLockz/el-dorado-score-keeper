import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import React from 'react';
import ReactDOM from 'react-dom/client';
import { waitFor } from '@testing-library/react';
import { INITIAL_STATE, type AppState, type KnownAppEvent } from '@/lib/state';
import { cleanupDevelopmentGlobals } from '../utils/component-lifecycle';

type MockAppStateHook = ReturnType<(typeof import('@/components/state-provider'))['useAppState']>;
type RouterStub = ReturnType<(typeof import('next/navigation'))['useRouter']>;

const setMockAppState = (globalThis as any).__setMockAppState as (value: MockAppStateHook) => void;
const setMockRouter = (globalThis as any).__setMockRouter as (router: RouterStub) => void;

const suite = typeof document === 'undefined' ? describe.skip : describe;

function createRouter() {
  return {
    push: vi.fn(),
    replace: vi.fn(),
    refresh: vi.fn(),
    forward: vi.fn(),
    back: vi.fn(),
    prefetch: vi.fn().mockResolvedValue(undefined),
  } satisfies RouterStub;
}

function setState(
  state: AppState,
  overrides: Partial<MockAppStateHook> & { appendMany?: MockAppStateHook['appendMany'] } = {},
) {
  setMockAppState({
    state,
    height: overrides.height ?? 0,
    ready: overrides.ready ?? true,
    append: overrides.append ?? (async () => 0),
    appendMany: overrides.appendMany ?? (async () => 0),
    isBatchPending: overrides.isBatchPending ?? false,
    previewAt: overrides.previewAt ?? (async () => state),
    warnings: overrides.warnings ?? [],
    clearWarnings: overrides.clearWarnings ?? (() => {}),
    timeTravelHeight: overrides.timeTravelHeight ?? null,
    setTimeTravelHeight: overrides.setTimeTravelHeight ?? (() => {}),
    timeTraveling: overrides.timeTraveling ?? false,
  } as MockAppStateHook);
}

async function renderNewPage() {
  const { default: NewPage } = await import('@/app/single-player/new/page');
  const container = document.createElement('div');
  document.body.appendChild(container);
  const root = ReactDOM.createRoot(container);
  root.render(React.createElement(NewPage));
  return { container, root };
}

suite('Single-player new game setup', () => {
  let router: RouterStub;
  let appendMany: vi.Mock<[KnownAppEvent[]], Promise<number>>;

  beforeEach(() => {
    // Enhanced cleanup for development globals
    cleanupDevelopmentGlobals();

    router = createRouter();
    setMockRouter(router);
    appendMany = vi.fn(async () => 0) as vi.Mock<[KnownAppEvent[]], Promise<number>>;
  });

  afterEach(() => {
    // Enhanced cleanup for development globals after each test
    cleanupDevelopmentGlobals();
  });

  it('clears inherited players before enabling actions', async () => {
    const state = structuredClone(INITIAL_STATE) as AppState;
    state.players = { p1: 'Alice', p2: 'Bot Bob' };
    state.display_order = { p1: 0, p2: 1 } as Record<string, number>;
    state.activeSingleRosterId = 'single-roster';
    state.rosters = {
      'single-roster': {
        name: 'Current Roster',
        playersById: { p1: 'Alice', p2: 'Bot Bob' },
        playerTypesById: { p1: 'human', p2: 'bot' },
        displayOrder: { p1: 0, p2: 1 },
        type: 'scorecard',
        createdAt: Date.now(),
        archivedAt: null,
      },
    } as AppState['rosters'];
    setState(state, { appendMany });

    const { container, root } = await renderNewPage();

    await waitFor(() => {
      expect(appendMany).toHaveBeenCalledTimes(1);
    });

    const events = appendMany.mock.calls[0]![0];
    expect(events.map((event) => event.type)).toEqual([
      'player/removed',
      'player/removed',
      'players/reordered',
      'roster/reset',
    ]);

    expect(container.textContent || '').toMatch(/Waiting for your new game/i);

    root.unmount();
    container.remove();
  });

  it('loads a saved roster into the new game session', async () => {
    const state = structuredClone(INITIAL_STATE) as AppState;
    state.players = {};
    state.sp = { ...state.sp, currentGameId: 'sp-new-1' } as AppState['sp'];
    state.rosters = {
      r1: {
        name: 'Solo Squad',
        playersById: { h1: 'Hero', b1: 'Bot One', b2: 'Bot Two' },
        playerTypesById: { h1: 'human', b1: 'bot', b2: 'bot' },
        displayOrder: { h1: 0, b1: 1, b2: 2 },
        type: 'scorecard',
        createdAt: Date.now(),
        archivedAt: null,
      },
    } as AppState['rosters'];
    setState(state, { appendMany });

    const { container, root } = await renderNewPage();

    await waitFor(() => {
      expect(container.textContent || '').toContain('Load roster');
    });

    const loadButton = Array.from(container.querySelectorAll('button')).find((btn) =>
      /Load roster/i.test(btn.textContent || ''),
    ) as HTMLButtonElement | undefined;
    expect(loadButton).toBeTruthy();
    loadButton?.click();

    await waitFor(() => {
      expect(appendMany).toHaveBeenCalledTimes(1);
    });

    const events = appendMany.mock.calls[0]![0];
    const types = events.map((event) => event.type);
    expect(types[0]).toBe('roster/created');
    const rosterAddedEvents = events.filter((event) => event.type === 'roster/player/added');
    expect(rosterAddedEvents).toHaveLength(3);
    const reorderIndex = types.indexOf('roster/players/reordered');
    expect(reorderIndex).toBe(rosterAddedEvents.length + 1);
    expect(types[reorderIndex + 1]).toBe('roster/activated');
    const playerEvents = events.filter((event) => event.type === 'player/added');
    expect(playerEvents).toHaveLength(3);
    expect(types.at(-1)).toBe('sp/human-set');
    expect(router.replace).toHaveBeenCalledWith('/single-player/sp-new-1');

    root.unmount();
    container.remove();
  });

  it('creates a placeholder lineup with bots', async () => {
    const state = structuredClone(INITIAL_STATE) as AppState;
    state.players = {};
    state.sp = { ...state.sp, currentGameId: 'sp-new-2' } as AppState['sp'];
    setState(state, { appendMany });

    const { container, root } = await renderNewPage();

    await waitFor(() => {
      expect(container.textContent || '').toContain('Create lineup');
    });

    const countButtons = Array.from(container.querySelectorAll('button')).filter((btn) =>
      /^[2-6]$/.test((btn.textContent || '').trim()),
    ) as HTMLButtonElement[];
    expect(countButtons.length).toBeGreaterThan(0);
    const sixPlayers = countButtons.find((btn) => btn.textContent?.trim() === '6');
    sixPlayers?.click();

    const createButton = Array.from(container.querySelectorAll('button')).find((btn) =>
      /Create lineup/i.test(btn.textContent || ''),
    ) as HTMLButtonElement | undefined;
    expect(createButton).toBeTruthy();
    createButton?.click();

    await waitFor(() => {
      expect(appendMany).toHaveBeenCalledTimes(1);
    });

    const events = appendMany.mock.calls[0]![0];
    const types = events.map((event) => event.type);
    expect(types[0]).toBe('roster/created');
    const rosterAddedEvents = events.filter((event) => event.type === 'roster/player/added');
    expect(rosterAddedEvents.length).toBeGreaterThanOrEqual(2);
    const reorderIndex = types.indexOf('roster/players/reordered');
    expect(reorderIndex).toBe(rosterAddedEvents.length + 1);
    expect(types[reorderIndex + 1]).toBe('roster/activated');
    const playerEvents = events.filter((event) => event.type === 'player/added');
    expect(playerEvents.length).toBeGreaterThanOrEqual(2);
    expect(playerEvents[0]?.payload).toMatchObject({ type: 'human', name: 'You' });
    playerEvents.slice(1).forEach((evt, idx) => {
      expect(evt.payload).toMatchObject({ type: 'bot', name: `Bot ${idx + 1}` });
    });
    expect(types.at(-1)).toBe('sp/human-set');
    expect(router.replace).toHaveBeenCalledWith('/single-player/sp-new-2');

    root.unmount();
    container.remove();
  });
});
